# 리액트 시작

## 왜 리액트 인가 ?

<br />

### 리액트의 등장 배경

<hr>
웹에서 주로 사용하는 자바스크립트는 한때 단순한 연산이나 시각적 효과를 주는 스크립트 언어에 불과했지만
형태의 웹 개발 방법론(AJAX 등)이 점차 발전하면서 웹 사이트의 동적인 렌더링을 자바스크립트로 하는 경우가 많아졌다.

하지만 오로지 순수한 자바스크립트만으로 규모가 큰 사이트를 만드려면 시간비용이 매우 많이 들어가게 되는데 이를 해결하기 위해 **Angular, Vue.js, React.js, Solid.js, Svelte** 등 그 외 여러가지 다양한 프레임워크와 라이브러리가 등장하게 되었다. 이런 프레임워크들은 주로 MVX (Model-View-X) 형태의 아키텍쳐로 앱을 구조화 하여 생산속도를 향상시켰는데 주 특징은 모델과 뷰를 따로 관리하여 데이터 조작부와 렌더링 과정을 분리시키는 것이다.

그러나 자바스크립트에서 동적으로 View를 렌더링 할 시 경우에 따라 이미 구성되어있던 레이아웃을 다시 계산해 내는 **Reflow**와 변경 사항을 적용해서 다시 그려내는 **Repaint** 가 발생하게 되는데 이 과정이 중첩될 경우 모든 계산이 끝난 후에 렌더링 하려 하므로 성능이 저하되어 큐 관리가 매우 어려워 진다.

이것에 대한 여러가지 해결방법이 있는데

1. 변경사항이 적용될 동안 요소를 숨긴다.
2. 가상요소 (DocumentFragment나, 요소복제 (cloneNode))를 사용후 변경사항을 한번에 반영
3. 캐싱 (reflow를 유발하는 메소드나 속성을 미리 할당해놓고 재사용하여 횟수를 줄임)
   등 외에도 여러가지 방법이 있다.

페이스북에서는 이러한 문제를 해결 하고자 어떤 아이디어를 고안해 냈다.  
데이터가 변경 될 때 마다 특정부분을 변화시키는게 아닌 기존의 뷰를 날려버리고 처음부터 새로 렌더링을 시켜 reflow 계산과정을 줄이겠다는 것인데 이런 아이디어에서 탄생한 것이 React 이다.

<br />

### 리액트 이해

<hr>

리액트는 프레임워크가 아닌 사용자 UI를 만드는데 사용되는 라이브러리다.

사용 패턴이 정해져있지 않아서 라이브러리라고 하지만 거의 정형화되어 프레임워크와 큰 차이가 없게 느껴지지만 그래도 사용자에 따라 사용방법이 달라질 수 있기때문에 라이브러리로 정의가 되어있다.

리액트는 위에서 말한 MVX의 프레임워크와는 다르게 오직 V(View)에만 신경쓰는 라이브러리다.
리액트에는 특정 부분이 어떻게 렌더링 되어야 할 지 정의하는 선언체가 있는데 이를 **컴포넌트(Component)**라고 정의한다.

이 컴포넌트는 다른 프레임워크에서 사용하는 Template보단 조금더 복잡한 개념이다.
일반적인 Template는 textReplace만을 위한 도구이지만 컴포넌트는 재사용이 가능한 API의 형태로 많은 기능들을 내장하고 있으며 자기자신의 작동방식을 정의 하는 요소이다.

컴포넌트는 성능을 아끼기 위해 **초기 렌더링**과, **리렌더링**이라는 과정을 거쳐 렌더링이 된다.

<br />

### 초기 렌더링

<hr>

리액트 컴포넌트에는 render라는 함수가 있는데 이 함수는 View에 사용될 template와 어떻게 작동할지에 대한 정보를 지닌 객체를 반환한다.

컴포넌트는 중첩이 가능하여 컴포넌트 내부에 또 다른 컴포넌트를 사용할 수 있으며 이때 상위 컴포넌트에서 render 함수를 실행하게 되면 그 내부에 있는 컴포넌트들도 재귀적으로 렌더링이 되어 주의해야 한다.

이렇게 컴포넌트의 렌더링 작업이 완료되면 지니고 있는 정보들을 사용하여 Markup을 완성시킨 후 실제 DOM 요소에 주입시킨다.

<br />

### 조화과정 (Reconciliation)

<hr>

리액트에서 뷰를 업데이트 할때는 "업데이트 한다" 라는 표현보다는 "조화 과정을 거친다(re-conciliation)"라고 하는게 조금 더 정확한 표현이다.  
컴포넌트가 update 되는것이 아닌 새로운 요소로 변경되기 때문이다.

이 작업 또한 render 함수가 담당하게 되는데 이전에 정의한 template에 새로 변경된 정보를 가지고 render 함수를 다시 호출한다.

이때 초기렌더링처럼 바로 반영 시키는 것이 아니라 기존에 만들어져 있던 DOMTree와 render함수에서 새로 생성된 DOMTree를 서로 비교하여 최소한의 연산으로 바뀐 부분만 DOMTree를 업데이트 시킨다.

결과적으로 방식 자체는 컴포넌트를 처음부터 새로 렌더링 하는 것 처럼 느껴지지만, 사실은 최적의 형태를 계산하여 변경 부분만 메모리에서 변경후 렌더링 수행하는 것이다.

<br />

### 간결성

<hr>

앞서 살펴본 내용처럼 리액트는 사용자가 정보만 변경을 해주면 알아서 메모리상의 가상 DOM Tree(Virtual DOM Tree)와 새로 만들어진 가상 DOM Tree를 비교하여 렌더링을 해주기 때문에 업데이트처리에 간결성이 매우 뛰어나다. 따라서 사용자가 UI를 업데이트 시키는 과정에서 생기는 복잡도가 매우 감소하게 되며 더욱 쉽게 DOM 업데이트에 접근할 수 있게 되는것이 REACT의 장점인 업데이트 간결성이다.

하지만 상태변경시 무조건 트리비교가 한번은 일어나게 되므로 비교 알고리즘에서 벗어난 케이스에는 성능문제가 발생할 수 있다.

<br />
